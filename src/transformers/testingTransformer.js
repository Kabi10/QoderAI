/**
 * Testing Transformer
 * Handles test generation and test-related enhancements
 */

import { BaseTransformer } from './BaseTransformer.js';

export default class TestingTransformer extends BaseTransformer {
  /**
   * Apply testing transformations to files
   * @param {Array} files - Files to transform
   * @param {Object} config - Testing configuration
   * @param {Object} context - Generation context
   * @returns {Array} Transformed files
   */
  async doTransform(files, config, context) {
    const transformedFiles = [...files];

    // Generate unit tests if enabled
    if (config.generateTests) {
      const testFiles = await this.generateTestFiles(files, config, context);
      transformedFiles.push(...testFiles);
    }

    // Generate E2E tests if enabled
    if (config.includeE2E) {
      const e2eFiles = await this.generateE2ETests(files, config, context);
      transformedFiles.push(...e2eFiles);
    }

    // Add test configuration files
    const configFiles = await this.generateTestConfigFiles(config, context);
    transformedFiles.push(...configFiles);

    // Enhance existing test files
    for (let i = 0; i < transformedFiles.length; i++) {
      if (this.isTestFile(transformedFiles[i])) {
        transformedFiles[i] = await this.enhanceTestFile(transformedFiles[i], config, context);
      }
    }

    return transformedFiles;
  }

  /**
   * Generate unit test files
   * @param {Array} files - Source files
   * @param {Object} config - Configuration
   * @param {Object} context - Generation context
   * @returns {Array} Test files
   */
  async generateTestFiles(files, config, context) {
    const testFiles = [];

    // Find source files that need tests
    const sourceFiles = files.filter(file => this.isSourceFile(file));

    for (const sourceFile of sourceFiles) {
      const testFile = await this.generateUnitTest(sourceFile, config, context);
      if (testFile) {
        testFiles.push(testFile);
      }
    }

    return testFiles;
  }

  /**
   * Generate unit test for a source file
   * @param {Object} sourceFile - Source file to test
   * @param {Object} config - Configuration
   * @param {Object} context - Generation context
   * @returns {Object} Test file
   */
  async generateUnitTest(sourceFile, config, context) {
    const testPath = this.getTestPath(sourceFile.path);
    const moduleName = this.extractModuleName(sourceFile.path);
    
    const testContent = this.generateTestContent(sourceFile, moduleName, context);

    this.logger.debug(`Generated unit test for ${sourceFile.path}`);

    return {
      path: testPath,
      content: testContent,
      size: Buffer.byteLength(testContent, 'utf8'),
      templateId: 'unit-test',
      generatedAt: new Date().toISOString()
    };
  }

  /**
   * Generate test content for a source file
   * @param {Object} sourceFile - Source file
   * @param {string} moduleName - Module name
   * @param {Object} context - Generation context
   * @returns {string} Test content
   */
  generateTestContent(sourceFile, moduleName, context) {
    const framework = this.getTestFramework(context);
    
    if (framework === 'jest') {
      return this.generateJestTest(sourceFile, moduleName, context);
    } else if (framework === 'mocha') {
      return this.generateMochaTest(sourceFile, moduleName, context);
    } else {
      return this.generateGenericTest(sourceFile, moduleName, context);
    }
  }

  /**
   * Generate Jest test content
   * @param {Object} sourceFile - Source file
   * @param {string} moduleName - Module name
   * @param {Object} context - Generation context
   * @returns {string} Jest test content
   */
  generateJestTest(sourceFile, moduleName, context) {
    const importPath = this.getRelativeImportPath(sourceFile.path);
    const functions = this.extractFunctions(sourceFile.content);

    return `/**
 * Unit tests for ${moduleName}
 * Generated by Testing Transformer
 */

import { ${functions.join(', ')} } from '${importPath}';

describe('${moduleName}', () => {
  ${functions.map(func => this.generateJestTestCase(func)).join('\n\n  ')}
});

describe('${moduleName} Integration', () => {
  test('should work with real dependencies', async () => {
    // Integration test placeholder
    expect(true).toBe(true);
  });
});
`;
  }

  /**
   * Generate Jest test case for a function
   * @param {string} functionName - Function name
   * @returns {string} Test case content
   */
  generateJestTestCase(functionName) {
    return `describe('${functionName}', () => {
    test('should return expected result', () => {
      // Arrange
      const input = {};
      const expected = {};

      // Act
      const result = ${functionName}(input);

      // Assert
      expect(result).toEqual(expected);
    });

    test('should handle edge cases', () => {
      // Test edge cases
      expect(() => ${functionName}(null)).not.toThrow();
    });
  });`;
  }

  /**
   * Generate Mocha test content
   * @param {Object} sourceFile - Source file
   * @param {string} moduleName - Module name
   * @param {Object} context - Generation context
   * @returns {string} Mocha test content
   */
  generateMochaTest(sourceFile, moduleName, context) {
    const importPath = this.getRelativeImportPath(sourceFile.path);
    const functions = this.extractFunctions(sourceFile.content);

    return `/**
 * Unit tests for ${moduleName}
 * Generated by Testing Transformer
 */

const { expect } = require('chai');
const { ${functions.join(', ')} } = require('${importPath}');

describe('${moduleName}', () => {
  ${functions.map(func => this.generateMochaTestCase(func)).join('\n\n  ')}
});
`;
  }

  /**
   * Generate Mocha test case for a function
   * @param {string} functionName - Function name
   * @returns {string} Test case content
   */
  generateMochaTestCase(functionName) {
    return `describe('${functionName}', () => {
    it('should return expected result', () => {
      // Arrange
      const input = {};
      const expected = {};

      // Act
      const result = ${functionName}(input);

      // Assert
      expect(result).to.deep.equal(expected);
    });

    it('should handle edge cases', () => {
      // Test edge cases
      expect(() => ${functionName}(null)).not.to.throw();
    });
  });`;
  }

  /**
   * Generate generic test content
   * @param {Object} sourceFile - Source file
   * @param {string} moduleName - Module name
   * @param {Object} context - Generation context
   * @returns {string} Generic test content
   */
  generateGenericTest(sourceFile, moduleName, context) {
    return `/**
 * Unit tests for ${moduleName}
 * Generated by Testing Transformer
 */

// TODO: Add appropriate test framework imports

describe('${moduleName}', () => {
  test('should have basic functionality', () => {
    // Add your test cases here
    expect(true).toBe(true);
  });
});
`;
  }

  /**
   * Generate E2E test files
   * @param {Array} files - Source files
   * @param {Object} config - Configuration
   * @param {Object} context - Generation context
   * @returns {Array} E2E test files
   */
  async generateE2ETests(files, config, context) {
    const e2eFiles = [];

    // Generate basic E2E test
    const e2eTest = await this.generateBasicE2ETest(config, context);
    if (e2eTest) {
      e2eFiles.push(e2eTest);
    }

    return e2eFiles;
  }

  /**
   * Generate basic E2E test
   * @param {Object} config - Configuration
   * @param {Object} context - Generation context
   * @returns {Object} E2E test file
   */
  async generateBasicE2ETest(config, context) {
    const content = `/**
 * End-to-End tests for ${context.projectName || 'Application'}
 * Generated by Testing Transformer
 */

describe('E2E Tests', () => {
  beforeAll(async () => {
    // Setup before all tests
  });

  afterAll(async () => {
    // Cleanup after all tests
  });

  test('should load the application', async () => {
    // Basic application load test
    expect(true).toBe(true);
  });

  test('should handle user workflows', async () => {
    // User workflow test
    expect(true).toBe(true);
  });
});
`;

    return {
      path: 'tests/e2e/app.e2e.test.js',
      content,
      size: Buffer.byteLength(content, 'utf8'),
      templateId: 'e2e-test',
      generatedAt: new Date().toISOString()
    };
  }

  /**
   * Generate test configuration files
   * @param {Object} config - Configuration
   * @param {Object} context - Generation context
   * @returns {Array} Configuration files
   */
  async generateTestConfigFiles(config, context) {
    const configFiles = [];

    // Generate Jest configuration
    const jestConfig = this.generateJestConfig(context);
    configFiles.push({
      path: 'jest.config.js',
      content: jestConfig,
      size: Buffer.byteLength(jestConfig, 'utf8'),
      templateId: 'jest-config',
      generatedAt: new Date().toISOString()
    });

    return configFiles;
  }

  /**
   * Generate Jest configuration
   * @param {Object} context - Generation context
   * @returns {string} Jest configuration content
   */
  generateJestConfig(context) {
    return `module.exports = {
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: [
    '**/__tests__/**/*.test.js',
    '**/?(*.)+(spec|test).js'
  ],
  collectCoverageFrom: [
    'src/**/*.js',
    '!src/**/*.test.js',
    '!src/index.js'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  verbose: true
};
`;
  }

  /**
   * Enhance existing test file
   * @param {Object} testFile - Test file to enhance
   * @param {Object} config - Configuration
   * @param {Object} context - Generation context
   * @returns {Object} Enhanced test file
   */
  async enhanceTestFile(testFile, config, context) {
    let content = testFile.content;

    // Add common test utilities if missing
    if (!content.includes('beforeEach') && !content.includes('afterEach')) {
      content = this.addTestHooks(content);
    }

    // Add coverage comments
    content = this.addCoverageComments(content);

    return this.updateFileContent(testFile, content);
  }

  /**
   * Add test hooks to test content
   * @param {string} content - Test content
   * @returns {string} Enhanced content
   */
  addTestHooks(content) {
    const hooks = `
  beforeEach(() => {
    // Setup before each test
  });

  afterEach(() => {
    // Cleanup after each test
  });
`;

    return content.replace(/describe\('([^']+)', \(\) => \{/, `describe('$1', () => {${hooks}`);
  }

  /**
   * Add coverage comments to test content
   * @param {string} content - Test content
   * @returns {string} Enhanced content
   */
  addCoverageComments(content) {
    if (!content.includes('/* istanbul ignore')) {
      return `/* istanbul ignore file */\n${content}`;
    }
    return content;
  }

  /**
   * Get test path for a source file
   * @param {string} sourcePath - Source file path
   * @returns {string} Test file path
   */
  getTestPath(sourcePath) {
    const pathWithoutExt = sourcePath.replace(/\.[^/.]+$/, '');
    return `${pathWithoutExt}.test.js`;
  }

  /**
   * Extract module name from file path
   * @param {string} filePath - File path
   * @returns {string} Module name
   */
  extractModuleName(filePath) {
    const fileName = filePath.split('/').pop() || filePath.split('\\').pop();
    return fileName?.replace(/\.[^/.]+$/, '') || 'Module';
  }

  /**
   * Get relative import path
   * @param {string} filePath - File path
   * @returns {string} Import path
   */
  getRelativeImportPath(filePath) {
    return `./${filePath.replace(/\.[^/.]+$/, '')}`;
  }

  /**
   * Extract function names from content
   * @param {string} content - File content
   * @returns {Array} Function names
   */
  extractFunctions(content) {
    const functions = [];
    
    // Extract function declarations and exports
    const patterns = [
      /export\s+function\s+(\w+)/g,
      /export\s+const\s+(\w+)\s*=/g,
      /function\s+(\w+)/g,
      /const\s+(\w+)\s*=\s*(?:async\s+)?\(/g
    ];

    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        if (!functions.includes(match[1])) {
          functions.push(match[1]);
        }
      }
    }

    return functions.length > 0 ? functions : ['defaultFunction'];
  }

  /**
   * Get test framework from context
   * @param {Object} context - Generation context
   * @returns {string} Test framework
   */
  getTestFramework(context) {
    if (context.techStack?.includes('Jest')) return 'jest';
    if (context.techStack?.includes('Mocha')) return 'mocha';
    return 'jest'; // Default to Jest
  }

  /**
   * Check if file is a source file that needs testing
   * @param {Object} file - File to check
   * @returns {boolean} Whether file needs testing
   */
  isSourceFile(file) {
    const sourceExtensions = ['.js', '.ts', '.jsx', '.tsx'];
    const excludePatterns = ['test', 'spec', 'config', 'index'];
    
    return sourceExtensions.some(ext => file.path.endsWith(ext)) &&
           !excludePatterns.some(pattern => file.path.toLowerCase().includes(pattern));
  }

  /**
   * Check if file is a test file
   * @param {Object} file - File to check
   * @returns {boolean} Whether file is a test file
   */
  isTestFile(file) {
    const testPatterns = ['test', 'spec', '__tests__'];
    return testPatterns.some(pattern => file.path.toLowerCase().includes(pattern));
  }
}